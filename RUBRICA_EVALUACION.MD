# Rúbrica de Evaluación: Taller de Lógica de Control (Evidencia de Desempeño)

**Estudiante:** \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
**Puntaje Total:** \_\_\_\_ / 100

---

| Criterio de Evaluación | Sobresaliente (90-100 pts) | Bueno (75-89 pts) | Suficiente (60-74 pts) | Insuficiente (0-59 pts) | Puntaje |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **1. Lógica y Funcionalidad (Peso: 40%)** <br/> *(Resuelve el problema planteado)* | El programa es 100% funcional. Resuelve la totalidad de los ejercicios planteados. La lógica del menú es impecable y todas las validaciones (ej. fondos insuficientes, montos positivos, rangos de notas) funcionan correctamente. | El programa es mayormente funcional. Resuelve casi todos los ejercicios, pero puede tener errores lógicos menores en algunas opciones del menú o en las validaciones (ej. permite un retiro con fondos exactos pero no menores). | El programa es parcialmente funcional. El menú principal funciona, pero varios ejercicios tienen fallos lógicos graves (ej. el cálculo del BMI es incorrecto, el saldo del ATM no se actualiza bien) o no se completaron. | El programa no es funcional, presenta errores de sintaxis que impiden su ejecución, o la lógica implementada no resuelve ninguno de los problemas planteados en los ejercicios. | |
| **2. Uso de Estructuras de Control (Peso: 30%)** <br/> *(Aplica las herramientas vistas)* | Utiliza de forma experta las estructuras de control requeridas: implementa un ciclo (`while` o `do-while`) para el menú principal, un `switch` para gestionar las opciones, e `if/else-if/else` anidados para las validaciones internas en *todos* los ejercicios. | Utiliza correctamente las estructuras de control en la mayoría de los ejercicios. Puede que en algún caso haya usado una cadena de `if` donde un `switch` era más óptimo, o viceversa, pero el programa funciona. | Utiliza las estructuras de forma inconsistente. Falla en implementar una de las estructuras clave (ej. no usa `switch` en ningún ejercicio o el menú no es cíclico) o las anida de forma incorrecta, generando fallos lógicos. | No aplica las estructuras de control solicitadas. El código no demuestra comprensión de ciclos, `switch` o condicionales anidados. | |
| **3. Calidad y Restricciones (Peso: 20%)** <br/> *(Sigue las reglas y buenas prácticas)* | Cumple *todas* las reglas: **No usa** `objetos`, `arreglos`, ni `funciones`. **No manipula el DOM**. El código sigue la convención `camelCase` estrictamente y los nombres de las variables son claros y descriptivos. | Cumple las reglas principales (sin arreglos/objetos/funciones). Puede tener fallos menores en las buenas prácticas, como nombres de variables poco descriptivos (ej. `n1`, `op`) o inconsistencias menores con `camelCase`. | Viola una de las reglas principales (ej. usó una función o un arreglo para "facilitar" el trabajo), lo cual estaba explícitamente penalizado. O el código es muy desordenado y los nombres de variables no son descriptivos. | Viola múltiples reglas principales (ej. usa arreglos Y funciones). El código es ilegible, no sigue ninguna convención y no cumple con las restricciones del taller. | |
| **4. Gestión del Repositorio (Peso: 10%)** <br/> *(Sigue el flujo de trabajo con Git)* | Sigue el flujo de trabajo a la perfección: Hizo `fork` del repositorio, lo clonó, y su historial de `git log` muestra múltiples *commits* descriptivos (ej. "Ejercicio 1: ATM terminado", "Ejercicio 2: Lógica de notas"). | Sigue el flujo de `fork` y `clone`. Sin embargo, solo realizó un *commit* grande al final ("Taller terminado") sin documentar el proceso. | No siguió el flujo de trabajo. No hizo `fork` (ej. descargó el ZIP o clonó el original) o no entregó un enlace al repositorio, sino que envió los archivos de otra manera. | No hay evidencia de uso de Git. | |